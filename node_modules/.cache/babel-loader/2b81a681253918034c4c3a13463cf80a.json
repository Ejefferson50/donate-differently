{"ast":null,"code":"// Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// @ts-ignore\n(function e(t, n, r) {\n  function s(o, u) {\n    if (!n[o]) {\n      if (!t[o]) {\n        var a = typeof require == 'function' && require; // @ts-ignore\n\n        if (!u && a) return a(o, !0); // @ts-ignore\n\n        if (i) return i(o, !0);\n        var f = new Error(\"Cannot find module '\" + o + \"'\"); // @ts-ignore\n\n        throw f.code = 'MODULE_NOT_FOUND', f;\n      }\n\n      var l = n[o] = {\n        exports: {}\n      };\n      t[o][0].call(l.exports, function (e) {\n        var n = t[o][1][e]; // @ts-ignore\n\n        return s(n ? n : e);\n      }, l, l.exports, e, t, n, r);\n    }\n\n    return n[o].exports;\n  }\n\n  var i = typeof require == 'function' && require; // @ts-ignore\n\n  for (var o = 0; o < r.length; o++) s(r[o]);\n\n  return s;\n})({\n  1: [function (require, module, exports) {\n    (function () {\n      'use strict';\n\n      var rec = require('./recorder.js');\n\n      var recorder,\n          audioRecorder,\n          checkAudioSupport,\n          audioSupported,\n          playbackSource,\n          UNSUPPORTED = 'Audio is not supported.';\n      /**\r\n       * Represents an audio control that can start and stop recording,\r\n       * export captured audio, play an audio buffer, and check if audio\r\n       * is supported.\r\n       */\n\n      exports.audioControl = function (options) {\n        options = options || {};\n        this.checkAudioSupport = options.checkAudioSupport !== false;\n        /**\r\n         * This callback type is called `onSilenceCallback`.\r\n         *\r\n         * @callback onSilenceCallback\r\n         */\n\n        /**\r\n         * Visualize callback: `visualizerCallback`.\r\n         *\r\n         * @callback visualizerCallback\r\n         * @param {Uint8Array} dataArray\r\n         * @param {number} bufferLength\r\n         */\n\n        /**\r\n         * Clears the previous buffer and starts buffering audio.\r\n         *\r\n         * @param {?onSilenceCallback} onSilence - Called when silence is detected.\r\n         * @param {?visualizerCallback} visualizer - Can be used to visualize the captured buffer.\r\n         * @param {silenceDetectionConfig} - Specify custom silence detection values.\r\n         * @throws {Error} If audio is not supported.\r\n         */\n\n        var startRecording = function (onSilence, visualizer, silenceDetectionConfig) {\n          onSilence = onSilence || function () {\n            /* no op */\n          };\n\n          visualizer = visualizer || function () {\n            /* no op */\n          };\n\n          audioSupported = audioSupported !== false;\n\n          if (!audioSupported) {\n            throw new Error(UNSUPPORTED);\n          }\n\n          var context = audioRecorder.audioContext();\n          context.resume().then(function () {\n            recorder = audioRecorder.createRecorder(silenceDetectionConfig);\n            recorder.record(onSilence, visualizer);\n          });\n        };\n        /**\r\n         * Stops buffering audio.\r\n         *\r\n         * @throws {Error} If audio is not supported.\r\n         */\n\n\n        var stopRecording = function () {\n          audioSupported = audioSupported !== false;\n\n          if (!audioSupported) {\n            throw new Error(UNSUPPORTED);\n          }\n\n          recorder.stop();\n        };\n        /**\r\n         * On export complete callback: `onExportComplete`.\r\n         *\r\n         * @callback onExportComplete\r\n         * @param {Blob} blob The exported audio as a Blob.\r\n         */\n\n        /**\r\n         * Exports the captured audio buffer.\r\n         *\r\n         * @param {onExportComplete} callback - Called when the export is complete.\r\n         * @param {sampleRate} The sample rate to use in the export.\r\n         * @throws {Error} If audio is not supported.\r\n         */\n\n\n        var exportWAV = function (callback, sampleRate) {\n          audioSupported = audioSupported !== false;\n\n          if (!audioSupported) {\n            throw new Error(UNSUPPORTED);\n          }\n\n          if (!(callback && typeof callback === 'function')) {\n            throw new Error('You must pass a callback function to export.');\n          }\n\n          sampleRate = typeof sampleRate !== 'undefined' ? sampleRate : 16000;\n          recorder.exportWAV(callback, sampleRate);\n          recorder.clear();\n        };\n        /**\r\n         * On playback complete callback: `onPlaybackComplete`.\r\n         *\r\n         * @callback onPlaybackComplete\r\n         */\n\n        /**\r\n         * Plays the audio buffer with an HTML5 audio tag.\r\n         * @param {Uint8Array} buffer - The audio buffer to play.\r\n         * @param {?onPlaybackComplete} callback - Called when audio playback is complete.\r\n         */\n\n\n        var playHtmlAudioElement = function (buffer, callback) {\n          if (typeof buffer === 'undefined') {\n            return;\n          }\n\n          var myBlob = new Blob([buffer]);\n          var audio = document.createElement('audio');\n          var objectUrl = window.URL.createObjectURL(myBlob);\n          audio.src = objectUrl;\n          audio.addEventListener('ended', function () {\n            audio.currentTime = 0;\n\n            if (typeof callback === 'function') {\n              callback();\n            }\n          });\n          audio.play();\n        };\n        /**\r\n         * On playback complete callback: `onPlaybackComplete`.\r\n         *\r\n         * @callback onPlaybackComplete\r\n         */\n\n        /**\r\n         * Plays the audio buffer with a WebAudio AudioBufferSourceNode.\r\n         * @param {Uint8Array} buffer - The audio buffer to play.\r\n         * @param {?onPlaybackComplete} callback - Called when audio playback is complete.\r\n         */\n\n\n        var play = function (buffer, callback) {\n          if (typeof buffer === 'undefined') {\n            return;\n          }\n\n          var myBlob = new Blob([buffer]); // We'll use a FileReader to create and ArrayBuffer out of the audio response.\n\n          var fileReader = new FileReader();\n\n          fileReader.onload = function () {\n            // Once we have an ArrayBuffer we can create our BufferSource and decode the result as an AudioBuffer.\n            playbackSource = audioRecorder.audioContext().createBufferSource();\n            audioRecorder.audioContext().decodeAudioData(this.result, function (buf) {\n              // Set the source buffer as our new AudioBuffer.\n              playbackSource.buffer = buf; // Set the destination (the actual audio-rendering device--your device's speakers).\n\n              playbackSource.connect(audioRecorder.audioContext().destination); // Add an \"on ended\" callback.\n\n              playbackSource.onended = function (event) {\n                if (typeof callback === 'function') {\n                  callback();\n                }\n              }; // Start the playback.\n\n\n              playbackSource.start(0);\n            });\n          };\n\n          fileReader.readAsArrayBuffer(myBlob);\n        };\n        /**\r\n         * Stops the playback source (created by the play method) if it exists. The `onPlaybackComplete`\r\n         * callback will be called.\r\n         */\n\n\n        var stop = function () {\n          if (typeof playbackSource === 'undefined') {\n            return;\n          }\n\n          playbackSource.stop();\n        };\n        /**\r\n         * Clear the recording buffer.\r\n         */\n\n\n        var clear = function () {\n          recorder.clear();\n        };\n        /**\r\n         * On audio supported callback: `onAudioSupported`.\r\n         *\r\n         * @callback onAudioSupported\r\n         * @param {boolean}\r\n         */\n\n        /**\r\n         * Checks that getUserMedia is supported and the user has given us access to the mic.\r\n         * @param {onAudioSupported} callback - Called with the result.\r\n         */\n\n\n        var supportsAudio = function (callback) {\n          callback = callback || function () {\n            /* no op */\n          };\n\n          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            audioRecorder = rec.audioRecorder();\n            audioRecorder.requestDevice().then(function (stream) {\n              audioSupported = true;\n              callback(audioSupported);\n            }).catch(function (error) {\n              audioSupported = false;\n              callback(audioSupported);\n            });\n          } else {\n            audioSupported = false;\n            callback(audioSupported);\n          }\n        };\n\n        if (this.checkAudioSupport) {\n          // @ts-ignore\n          supportsAudio();\n        }\n\n        return {\n          startRecording: startRecording,\n          stopRecording: stopRecording,\n          exportWAV: exportWAV,\n          play: play,\n          stop: stop,\n          clear: clear,\n          playHtmlAudioElement: playHtmlAudioElement,\n          supportsAudio: supportsAudio\n        };\n      };\n    })();\n  }, {\n    './recorder.js': 5\n  }],\n  2: [function (require, module, exports) {\n    (function () {\n      'use strict';\n\n      var AudioControl = require('./control.js').audioControl;\n\n      var DEFAULT_LATEST = '$LATEST';\n      var DEFAULT_CONTENT_TYPE = 'audio/x-l16; sample-rate=16000';\n      var DEFAULT_USER_ID = 'userId';\n      var DEFAULT_ACCEPT_HEADER_VALUE = 'audio/mpeg';\n      var MESSAGES = Object.freeze({\n        PASSIVE: 'Passive',\n        LISTENING: 'Listening',\n        SENDING: 'Sending',\n        SPEAKING: 'Speaking'\n      });\n      var lexruntime,\n          audioControl = new AudioControl({\n        checkAudioSupport: false\n      });\n\n      exports.conversation = function (config, onStateChange, onSuccess, onError, onAudioData) {\n        var currentState; // Apply default values.\n\n        this.config = applyDefaults(config);\n        this.lexConfig = this.config.lexConfig;\n        this.messages = MESSAGES;\n\n        onStateChange = onStateChange || function () {\n          /* no op */\n        };\n\n        this.onSuccess = onSuccess || function () {\n          /* no op */\n        };\n\n        this.onError = onError || function () {\n          /* no op */\n        };\n\n        this.onAudioData = onAudioData || function () {\n          /* no op */\n        }; // Validate input.\n\n\n        if (!this.config.lexConfig.botName) {\n          this.onError('A Bot name must be provided.');\n          return;\n        } // @ts-ignore\n\n\n        if (!AWS.config.credentials) {\n          this.onError('AWS Credentials must be provided.');\n          return;\n        } // @ts-ignore\n\n\n        if (!AWS.config.region) {\n          this.onError('A Region value must be provided.');\n          return;\n        } // @ts-ignore\n\n\n        lexruntime = new AWS.LexRuntime();\n\n        this.onSilence = function () {\n          if (config.silenceDetection) {\n            audioControl.stopRecording();\n            currentState.advanceConversation();\n          }\n        };\n\n        this.transition = function (conversation) {\n          currentState = conversation;\n          var state = currentState.state;\n          onStateChange(state.message); // If we are transitioning into SENDING or SPEAKING we want to immediately advance the conversation state\n          // to start the service call or playback.\n\n          if (state.message === state.messages.SENDING || state.message === state.messages.SPEAKING) {\n            currentState.advanceConversation();\n          } // If we are transitioning in to sending and we are not detecting silence (this was a manual state change)\n          // we need to do some cleanup: stop recording, and stop rendering.\n\n\n          if (state.message === state.messages.SENDING && !this.config.silenceDetection) {\n            audioControl.stopRecording();\n          }\n        };\n\n        this.advanceConversation = function () {\n          audioControl.supportsAudio(function (supported) {\n            if (supported) {\n              currentState.advanceConversation();\n            } else {\n              onError('Audio is not supported.');\n            }\n          });\n        };\n\n        this.updateConfig = function (newValue) {\n          this.config = applyDefaults(newValue);\n          this.lexConfig = this.config.lexConfig;\n        };\n\n        this.reset = function () {\n          audioControl.clear();\n          currentState = new Initial(currentState.state);\n        };\n\n        currentState = new Initial(this);\n        return {\n          advanceConversation: this.advanceConversation,\n          updateConfig: this.updateConfig,\n          reset: this.reset\n        };\n      };\n\n      var Initial = function (state) {\n        this.state = state;\n        state.message = state.messages.PASSIVE;\n\n        this.advanceConversation = function () {\n          audioControl.startRecording(state.onSilence, state.onAudioData, state.config.silenceDetectionConfig);\n          state.transition(new Listening(state));\n        };\n      };\n\n      var Listening = function (state) {\n        this.state = state;\n        state.message = state.messages.LISTENING;\n\n        this.advanceConversation = function () {\n          audioControl.exportWAV(function (blob) {\n            state.audioInput = blob;\n            state.transition(new Sending(state));\n          });\n        };\n      };\n\n      var Sending = function (state) {\n        this.state = state;\n        state.message = state.messages.SENDING;\n\n        this.advanceConversation = function () {\n          state.lexConfig.inputStream = state.audioInput;\n          lexruntime.postContent(state.lexConfig, function (err, data) {\n            if (err) {\n              state.onError(err);\n              state.transition(new Initial(state));\n            } else {\n              state.audioOutput = data;\n              state.transition(new Speaking(state));\n              state.onSuccess(data);\n            }\n          });\n        };\n      };\n\n      var Speaking = function (state) {\n        this.state = state;\n        state.message = state.messages.SPEAKING;\n\n        this.advanceConversation = function () {\n          if (state.audioOutput.contentType === 'audio/mpeg') {\n            audioControl.play(state.audioOutput.audioStream, function () {\n              if (state.audioOutput.dialogState === 'ReadyForFulfillment' || state.audioOutput.dialogState === 'Fulfilled' || state.audioOutput.dialogState === 'Failed' || !state.config.silenceDetection) {\n                state.transition(new Initial(state));\n              } else {\n                audioControl.startRecording(state.onSilence, state.onAudioData, state.config.silenceDetectionConfig);\n                state.transition(new Listening(state));\n              }\n            });\n          } else {\n            state.transition(new Initial(state));\n          }\n        };\n      };\n\n      var applyDefaults = function (config) {\n        config = config || {};\n        config.silenceDetection = config.hasOwnProperty('silenceDetection') ? config.silenceDetection : true;\n        var lexConfig = config.lexConfig || {};\n        lexConfig.botAlias = lexConfig.hasOwnProperty('botAlias') ? lexConfig.botAlias : DEFAULT_LATEST;\n        lexConfig.botName = lexConfig.hasOwnProperty('botName') ? lexConfig.botName : '';\n        lexConfig.contentType = lexConfig.hasOwnProperty('contentType') ? lexConfig.contentType : DEFAULT_CONTENT_TYPE;\n        lexConfig.userId = lexConfig.hasOwnProperty('userId') ? lexConfig.userId : DEFAULT_USER_ID;\n        lexConfig.accept = lexConfig.hasOwnProperty('accept') ? lexConfig.accept : DEFAULT_ACCEPT_HEADER_VALUE;\n        config.lexConfig = lexConfig;\n        return config;\n      };\n    })();\n  }, {\n    './control.js': 1\n  }],\n  3: [function (require, module, exports) {\n    (function (global) {\n      /**\r\n       * @module LexAudio\r\n       * @description The global namespace for Amazon Lex Audio\r\n       */\n      global.LexAudio = global.LexAudio || {};\n      global.LexAudio.audioControl = require('./control.js').audioControl;\n      global.LexAudio.conversation = require('./conversation.js').conversation;\n      module.exports = global.LexAudio;\n    }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});\n  }, {\n    './control.js': 1,\n    './conversation.js': 2\n  }],\n  4: [function (require, module, exports) {\n    var bundleFn = arguments[3];\n    var sources = arguments[4];\n    var cache = arguments[5];\n    var stringify = JSON.stringify;\n\n    module.exports = function (fn, options) {\n      var wkey;\n      var cacheKeys = Object.keys(cache);\n\n      for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports; // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n\n        if (exp === fn || exp && exp.default === fn) {\n          wkey = key;\n          break;\n        }\n      }\n\n      if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n          var key = cacheKeys[i];\n          wcache[key] = key;\n        }\n\n        sources[wkey] = [// @ts-ignore\n        Function(['require', 'module', 'exports'], '(' + fn + ')(self)'), wcache];\n      }\n\n      var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n      var scache = {};\n      scache[wkey] = wkey;\n      sources[skey] = [// @ts-ignore\n      Function( // @ts-ignore\n      ['require'], // try to call default if defined to also support babel esmodule\n      // exports\n      'var f = require(' + stringify(wkey) + ');' + '(f.default ? f.default : f)(self);'), scache];\n      var workerSources = {};\n      resolveSources(skey);\n\n      function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n          var depKey = sources[key][1][depPath];\n\n          if (!workerSources[depKey]) {\n            resolveSources(depKey);\n          }\n        }\n      }\n\n      var src = '(' + bundleFn + ')({' + Object.keys(workerSources).map(function (key) {\n        return stringify(key) + ':[' + sources[key][0] + ',' + stringify(sources[key][1]) + ']';\n      }).join(',') + '},{},[' + stringify(skey) + '])'; // @ts-ignore\n\n      var URL = // @ts-ignore\n      window.URL || window.webkitURL || window.mozURL || window.msURL;\n      var blob = new Blob([src], {\n        type: 'text/javascript'\n      });\n\n      if (options && options.bare) {\n        return blob;\n      }\n\n      var workerUrl = URL.createObjectURL(blob);\n      var worker = new Worker(workerUrl); // @ts-ignore\n\n      worker.objectURL = workerUrl;\n      return worker;\n    };\n  }, {}],\n  5: [function (require, module, exports) {\n    (function () {\n      'use strict';\n\n      var work = require('webworkify');\n\n      var worker = work(require('./worker.js'));\n      var audio_context, audio_stream;\n      /**\r\n       * The Recorder object. Sets up the onaudioprocess callback and communicates\r\n       * with the web worker to perform audio actions.\r\n       */\n\n      var recorder = function (source, silenceDetectionConfig) {\n        silenceDetectionConfig = silenceDetectionConfig || {};\n        silenceDetectionConfig.time = silenceDetectionConfig.hasOwnProperty('time') ? silenceDetectionConfig.time : 1500;\n        silenceDetectionConfig.amplitude = silenceDetectionConfig.hasOwnProperty('amplitude') ? silenceDetectionConfig.amplitude : 0.2;\n        var recording = false,\n            currCallback,\n            start,\n            silenceCallback,\n            visualizationCallback; // Create a ScriptProcessorNode with a bufferSize of 4096 and a single input and output channel\n\n        var node = source.context.createScriptProcessor(4096, 1, 1);\n\n        worker.onmessage = function (message) {\n          var blob = message.data;\n          currCallback(blob);\n        };\n\n        worker.postMessage({\n          command: 'init',\n          config: {\n            sampleRate: source.context.sampleRate\n          }\n        });\n        /**\r\n         * Sets the silence and viz callbacks, resets the silence start time, and sets recording to true.\r\n         * @param {?onSilenceCallback} onSilence - Called when silence is detected.\r\n         * @param {?visualizerCallback} visualizer - Can be used to visualize the captured buffer.\r\n         */\n\n        var record = function (onSilence, visualizer) {\n          silenceCallback = onSilence;\n          visualizationCallback = visualizer;\n          start = Date.now();\n          recording = true;\n        };\n        /**\r\n         * Sets recording to false.\r\n         */\n\n\n        var stop = function () {\n          recording = false;\n        };\n        /**\r\n         * Posts \"clear\" message to the worker.\r\n         */\n\n\n        var clear = function () {\n          stop();\n          worker.postMessage({\n            command: 'clear'\n          });\n        };\n        /**\r\n         * Sets the export callback and posts an \"export\" message to the worker.\r\n         * @param {onExportComplete} callback - Called when the export is complete.\r\n         * @param {sampleRate} The sample rate to use in the export.\r\n         */\n\n\n        var exportWAV = function (callback, sampleRate) {\n          currCallback = callback;\n          worker.postMessage({\n            command: 'export',\n            sampleRate: sampleRate\n          });\n        };\n        /**\r\n         * Checks the time domain data to see if the amplitude of the audio waveform is more than\r\n         * the silence threshold. If it is, \"noise\" has been detected and it resets the start time.\r\n         * If the elapsed time reaches the time threshold the silence callback is called. If there is a\r\n         * visualizationCallback it invokes the visualization callback with the time domain data.\r\n         */\n\n\n        var analyse = function () {\n          analyser.fftSize = 2048;\n          var bufferLength = analyser.fftSize;\n          var dataArray = new Uint8Array(bufferLength);\n          var amplitude = silenceDetectionConfig.amplitude;\n          var time = silenceDetectionConfig.time;\n          analyser.getByteTimeDomainData(dataArray);\n\n          if (typeof visualizationCallback === 'function') {\n            visualizationCallback(dataArray, bufferLength);\n          }\n\n          for (var i = 0; i < bufferLength; i++) {\n            // Normalize between -1 and 1.\n            var curr_value_time = dataArray[i] / 128 - 1.0;\n\n            if (curr_value_time > amplitude || curr_value_time < -1 * amplitude) {\n              start = Date.now();\n            }\n          }\n\n          var newtime = Date.now();\n          var elapsedTime = newtime - start;\n\n          if (elapsedTime > time) {\n            silenceCallback();\n          }\n        };\n        /**\r\n         * The onaudioprocess event handler of the ScriptProcessorNode interface. It is the EventHandler to be\r\n         * called for the audioprocess event that is dispatched to ScriptProcessorNode node types.\r\n         * @param {AudioProcessingEvent} audioProcessingEvent - The audio processing event.\r\n         */\n\n\n        node.onaudioprocess = function (audioProcessingEvent) {\n          if (!recording) {\n            return;\n          }\n\n          worker.postMessage({\n            command: 'record',\n            buffer: [audioProcessingEvent.inputBuffer.getChannelData(0)]\n          });\n          analyse();\n        };\n\n        var analyser = source.context.createAnalyser();\n        analyser.minDecibels = -90;\n        analyser.maxDecibels = -10;\n        analyser.smoothingTimeConstant = 0.85;\n        source.connect(analyser);\n        analyser.connect(node);\n        node.connect(source.context.destination);\n        return {\n          record: record,\n          stop: stop,\n          clear: clear,\n          exportWAV: exportWAV\n        };\n      };\n      /**\r\n       * Audio recorder object. Handles setting up the audio context,\r\n       * accessing the mike, and creating the Recorder object.\r\n       */\n\n\n      exports.audioRecorder = function () {\n        /**\r\n         * Creates an audio context and calls getUserMedia to request the mic (audio).\r\n         */\n        var requestDevice = function () {\n          if (typeof audio_context === 'undefined') {\n            // @ts-ignore\n            window.AudioContext = // @ts-ignore\n            window.AudioContext || window.webkitAudioContext;\n            audio_context = new AudioContext();\n          }\n\n          return navigator.mediaDevices.getUserMedia({\n            audio: true\n          }).then(function (stream) {\n            audio_stream = stream;\n          });\n        };\n\n        var createRecorder = function (silenceDetectionConfig) {\n          return recorder(audio_context.createMediaStreamSource(audio_stream), silenceDetectionConfig);\n        };\n\n        var audioContext = function () {\n          return audio_context;\n        };\n\n        return {\n          requestDevice: requestDevice,\n          createRecorder: createRecorder,\n          audioContext: audioContext\n        };\n      };\n    })();\n  }, {\n    './worker.js': 6,\n    webworkify: 4\n  }],\n  6: [function (require, module, exports) {\n    module.exports = function (self) {\n      'use strict';\n\n      var recLength = 0,\n          recBuffer = [],\n          recordSampleRate;\n      self.addEventListener('message', function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n\n          case 'record':\n            record(e.data.buffer);\n            break;\n\n          case 'export':\n            exportBuffer(e.data.sampleRate);\n            break;\n\n          case 'clear':\n            clear();\n            break;\n        }\n      });\n\n      function init(config) {\n        recordSampleRate = config.sampleRate;\n      }\n\n      function record(inputBuffer) {\n        recBuffer.push(inputBuffer[0]);\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportBuffer(exportSampleRate) {\n        var mergedBuffers = mergeBuffers(recBuffer, recLength);\n        var downsampledBuffer = downsampleBuffer(mergedBuffers, exportSampleRate);\n        var encodedWav = encodeWAV(downsampledBuffer);\n        var audioBlob = new Blob([encodedWav], {\n          type: 'application/octet-stream'\n        }); // @ts-ignore\n\n        postMessage(audioBlob);\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffer = [];\n      }\n\n      function downsampleBuffer(buffer, exportSampleRate) {\n        if (exportSampleRate === recordSampleRate) {\n          return buffer;\n        }\n\n        var sampleRateRatio = recordSampleRate / exportSampleRate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n          var accum = 0,\n              count = 0;\n\n          for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n          }\n\n          result[offsetResult] = accum / count;\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n\n        return result;\n      }\n\n      function mergeBuffers(bufferArray, recLength) {\n        var result = new Float32Array(recLength);\n        var offset = 0;\n\n        for (var i = 0; i < bufferArray.length; i++) {\n          result.set(bufferArray[i], offset);\n          offset += bufferArray[i].length;\n        }\n\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (var i = 0; i < input.length; i++, offset += 2) {\n          var s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (var i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      function encodeWAV(samples) {\n        var buffer = new ArrayBuffer(44 + samples.length * 2);\n        var view = new DataView(buffer);\n        writeString(view, 0, 'RIFF');\n        view.setUint32(4, 32 + samples.length * 2, true);\n        writeString(view, 8, 'WAVE');\n        writeString(view, 12, 'fmt ');\n        view.setUint32(16, 16, true);\n        view.setUint16(20, 1, true);\n        view.setUint16(22, 1, true);\n        view.setUint32(24, recordSampleRate, true);\n        view.setUint32(28, recordSampleRate * 2, true);\n        view.setUint16(32, 2, true);\n        view.setUint16(34, 16, true);\n        writeString(view, 36, 'data');\n        view.setUint32(40, samples.length * 2, true);\n        floatTo16BitPCM(view, 44, samples);\n        return view;\n      }\n    };\n  }, {}]\n}, {}, [3]);","map":{"version":3,"sources":["../../src/Interactions/aws-lex-audio.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n// software and associated documentation files (the \"Software\"), to deal in the Software\r\n// without restriction, including without limitation the rights to use, copy, modify,\r\n// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n// permit persons to whom the Software is furnished to do so.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n// @ts-ignore\r\n(function e(t, n, r) {\r\n    function s(o, u) {\r\n        if (!n[o]) {\r\n            if (!t[o]) {\r\n                var a = typeof require == 'function' && require;\r\n                // @ts-ignore\r\n                if (!u && a)\r\n                    return a(o, !0);\r\n                // @ts-ignore\r\n                if (i)\r\n                    return i(o, !0);\r\n                var f = new Error(\"Cannot find module '\" + o + \"'\");\r\n                // @ts-ignore\r\n                throw ((f.code = 'MODULE_NOT_FOUND'), f);\r\n            }\r\n            var l = (n[o] = { exports: {} });\r\n            t[o][0].call(l.exports, function (e) {\r\n                var n = t[o][1][e];\r\n                // @ts-ignore\r\n                return s(n ? n : e);\r\n            }, l, l.exports, e, t, n, r);\r\n        }\r\n        return n[o].exports;\r\n    }\r\n    var i = typeof require == 'function' && require;\r\n    // @ts-ignore\r\n    for (var o = 0; o < r.length; o++)\r\n        s(r[o]);\r\n    return s;\r\n})({\r\n    1: [\r\n        function (require, module, exports) {\r\n            (function () {\r\n                'use strict';\r\n                var rec = require('./recorder.js');\r\n                var recorder, audioRecorder, checkAudioSupport, audioSupported, playbackSource, UNSUPPORTED = 'Audio is not supported.';\r\n                /**\r\n                 * Represents an audio control that can start and stop recording,\r\n                 * export captured audio, play an audio buffer, and check if audio\r\n                 * is supported.\r\n                 */\r\n                exports.audioControl = function (options) {\r\n                    options = options || {};\r\n                    this.checkAudioSupport = options.checkAudioSupport !== false;\r\n                    /**\r\n                     * This callback type is called `onSilenceCallback`.\r\n                     *\r\n                     * @callback onSilenceCallback\r\n                     */\r\n                    /**\r\n                     * Visualize callback: `visualizerCallback`.\r\n                     *\r\n                     * @callback visualizerCallback\r\n                     * @param {Uint8Array} dataArray\r\n                     * @param {number} bufferLength\r\n                     */\r\n                    /**\r\n                     * Clears the previous buffer and starts buffering audio.\r\n                     *\r\n                     * @param {?onSilenceCallback} onSilence - Called when silence is detected.\r\n                     * @param {?visualizerCallback} visualizer - Can be used to visualize the captured buffer.\r\n                     * @param {silenceDetectionConfig} - Specify custom silence detection values.\r\n                     * @throws {Error} If audio is not supported.\r\n                     */\r\n                    var startRecording = function (onSilence, visualizer, silenceDetectionConfig) {\r\n                        onSilence =\r\n                            onSilence ||\r\n                                function () {\r\n                                    /* no op */\r\n                                };\r\n                        visualizer =\r\n                            visualizer ||\r\n                                function () {\r\n                                    /* no op */\r\n                                };\r\n                        audioSupported = audioSupported !== false;\r\n                        if (!audioSupported) {\r\n                            throw new Error(UNSUPPORTED);\r\n                        }\r\n                        var context = audioRecorder.audioContext();\r\n                        context.resume().then(function () {\r\n                            recorder = audioRecorder.createRecorder(silenceDetectionConfig);\r\n                            recorder.record(onSilence, visualizer);\r\n                        });\r\n                    };\r\n                    /**\r\n                     * Stops buffering audio.\r\n                     *\r\n                     * @throws {Error} If audio is not supported.\r\n                     */\r\n                    var stopRecording = function () {\r\n                        audioSupported = audioSupported !== false;\r\n                        if (!audioSupported) {\r\n                            throw new Error(UNSUPPORTED);\r\n                        }\r\n                        recorder.stop();\r\n                    };\r\n                    /**\r\n                     * On export complete callback: `onExportComplete`.\r\n                     *\r\n                     * @callback onExportComplete\r\n                     * @param {Blob} blob The exported audio as a Blob.\r\n                     */\r\n                    /**\r\n                     * Exports the captured audio buffer.\r\n                     *\r\n                     * @param {onExportComplete} callback - Called when the export is complete.\r\n                     * @param {sampleRate} The sample rate to use in the export.\r\n                     * @throws {Error} If audio is not supported.\r\n                     */\r\n                    var exportWAV = function (callback, sampleRate) {\r\n                        audioSupported = audioSupported !== false;\r\n                        if (!audioSupported) {\r\n                            throw new Error(UNSUPPORTED);\r\n                        }\r\n                        if (!(callback && typeof callback === 'function')) {\r\n                            throw new Error('You must pass a callback function to export.');\r\n                        }\r\n                        sampleRate =\r\n                            typeof sampleRate !== 'undefined' ? sampleRate : 16000;\r\n                        recorder.exportWAV(callback, sampleRate);\r\n                        recorder.clear();\r\n                    };\r\n                    /**\r\n                     * On playback complete callback: `onPlaybackComplete`.\r\n                     *\r\n                     * @callback onPlaybackComplete\r\n                     */\r\n                    /**\r\n                     * Plays the audio buffer with an HTML5 audio tag.\r\n                     * @param {Uint8Array} buffer - The audio buffer to play.\r\n                     * @param {?onPlaybackComplete} callback - Called when audio playback is complete.\r\n                     */\r\n                    var playHtmlAudioElement = function (buffer, callback) {\r\n                        if (typeof buffer === 'undefined') {\r\n                            return;\r\n                        }\r\n                        var myBlob = new Blob([buffer]);\r\n                        var audio = document.createElement('audio');\r\n                        var objectUrl = window.URL.createObjectURL(myBlob);\r\n                        audio.src = objectUrl;\r\n                        audio.addEventListener('ended', function () {\r\n                            audio.currentTime = 0;\r\n                            if (typeof callback === 'function') {\r\n                                callback();\r\n                            }\r\n                        });\r\n                        audio.play();\r\n                    };\r\n                    /**\r\n                     * On playback complete callback: `onPlaybackComplete`.\r\n                     *\r\n                     * @callback onPlaybackComplete\r\n                     */\r\n                    /**\r\n                     * Plays the audio buffer with a WebAudio AudioBufferSourceNode.\r\n                     * @param {Uint8Array} buffer - The audio buffer to play.\r\n                     * @param {?onPlaybackComplete} callback - Called when audio playback is complete.\r\n                     */\r\n                    var play = function (buffer, callback) {\r\n                        if (typeof buffer === 'undefined') {\r\n                            return;\r\n                        }\r\n                        var myBlob = new Blob([buffer]);\r\n                        // We'll use a FileReader to create and ArrayBuffer out of the audio response.\r\n                        var fileReader = new FileReader();\r\n                        fileReader.onload = function () {\r\n                            // Once we have an ArrayBuffer we can create our BufferSource and decode the result as an AudioBuffer.\r\n                            playbackSource = audioRecorder\r\n                                .audioContext()\r\n                                .createBufferSource();\r\n                            audioRecorder\r\n                                .audioContext()\r\n                                .decodeAudioData(this.result, function (buf) {\r\n                                // Set the source buffer as our new AudioBuffer.\r\n                                playbackSource.buffer = buf;\r\n                                // Set the destination (the actual audio-rendering device--your device's speakers).\r\n                                playbackSource.connect(audioRecorder.audioContext().destination);\r\n                                // Add an \"on ended\" callback.\r\n                                playbackSource.onended = function (event) {\r\n                                    if (typeof callback === 'function') {\r\n                                        callback();\r\n                                    }\r\n                                };\r\n                                // Start the playback.\r\n                                playbackSource.start(0);\r\n                            });\r\n                        };\r\n                        fileReader.readAsArrayBuffer(myBlob);\r\n                    };\r\n                    /**\r\n                     * Stops the playback source (created by the play method) if it exists. The `onPlaybackComplete`\r\n                     * callback will be called.\r\n                     */\r\n                    var stop = function () {\r\n                        if (typeof playbackSource === 'undefined') {\r\n                            return;\r\n                        }\r\n                        playbackSource.stop();\r\n                    };\r\n                    /**\r\n                     * Clear the recording buffer.\r\n                     */\r\n                    var clear = function () {\r\n                        recorder.clear();\r\n                    };\r\n                    /**\r\n                     * On audio supported callback: `onAudioSupported`.\r\n                     *\r\n                     * @callback onAudioSupported\r\n                     * @param {boolean}\r\n                     */\r\n                    /**\r\n                     * Checks that getUserMedia is supported and the user has given us access to the mic.\r\n                     * @param {onAudioSupported} callback - Called with the result.\r\n                     */\r\n                    var supportsAudio = function (callback) {\r\n                        callback =\r\n                            callback ||\r\n                                function () {\r\n                                    /* no op */\r\n                                };\r\n                        if (navigator.mediaDevices &&\r\n                            navigator.mediaDevices.getUserMedia) {\r\n                            audioRecorder = rec.audioRecorder();\r\n                            audioRecorder\r\n                                .requestDevice()\r\n                                .then(function (stream) {\r\n                                audioSupported = true;\r\n                                callback(audioSupported);\r\n                            })\r\n                                .catch(function (error) {\r\n                                audioSupported = false;\r\n                                callback(audioSupported);\r\n                            });\r\n                        }\r\n                        else {\r\n                            audioSupported = false;\r\n                            callback(audioSupported);\r\n                        }\r\n                    };\r\n                    if (this.checkAudioSupport) {\r\n                        // @ts-ignore\r\n                        supportsAudio();\r\n                    }\r\n                    return {\r\n                        startRecording: startRecording,\r\n                        stopRecording: stopRecording,\r\n                        exportWAV: exportWAV,\r\n                        play: play,\r\n                        stop: stop,\r\n                        clear: clear,\r\n                        playHtmlAudioElement: playHtmlAudioElement,\r\n                        supportsAudio: supportsAudio,\r\n                    };\r\n                };\r\n            })();\r\n        },\r\n        { './recorder.js': 5 },\r\n    ],\r\n    2: [\r\n        function (require, module, exports) {\r\n            (function () {\r\n                'use strict';\r\n                var AudioControl = require('./control.js').audioControl;\r\n                var DEFAULT_LATEST = '$LATEST';\r\n                var DEFAULT_CONTENT_TYPE = 'audio/x-l16; sample-rate=16000';\r\n                var DEFAULT_USER_ID = 'userId';\r\n                var DEFAULT_ACCEPT_HEADER_VALUE = 'audio/mpeg';\r\n                var MESSAGES = Object.freeze({\r\n                    PASSIVE: 'Passive',\r\n                    LISTENING: 'Listening',\r\n                    SENDING: 'Sending',\r\n                    SPEAKING: 'Speaking',\r\n                });\r\n                var lexruntime, audioControl = new AudioControl({ checkAudioSupport: false });\r\n                exports.conversation = function (config, onStateChange, onSuccess, onError, onAudioData) {\r\n                    var currentState;\r\n                    // Apply default values.\r\n                    this.config = applyDefaults(config);\r\n                    this.lexConfig = this.config.lexConfig;\r\n                    this.messages = MESSAGES;\r\n                    onStateChange =\r\n                        onStateChange ||\r\n                            function () {\r\n                                /* no op */\r\n                            };\r\n                    this.onSuccess =\r\n                        onSuccess ||\r\n                            function () {\r\n                                /* no op */\r\n                            };\r\n                    this.onError =\r\n                        onError ||\r\n                            function () {\r\n                                /* no op */\r\n                            };\r\n                    this.onAudioData =\r\n                        onAudioData ||\r\n                            function () {\r\n                                /* no op */\r\n                            };\r\n                    // Validate input.\r\n                    if (!this.config.lexConfig.botName) {\r\n                        this.onError('A Bot name must be provided.');\r\n                        return;\r\n                    }\r\n                    // @ts-ignore\r\n                    if (!AWS.config.credentials) {\r\n                        this.onError('AWS Credentials must be provided.');\r\n                        return;\r\n                    }\r\n                    // @ts-ignore\r\n                    if (!AWS.config.region) {\r\n                        this.onError('A Region value must be provided.');\r\n                        return;\r\n                    }\r\n                    // @ts-ignore\r\n                    lexruntime = new AWS.LexRuntime();\r\n                    this.onSilence = function () {\r\n                        if (config.silenceDetection) {\r\n                            audioControl.stopRecording();\r\n                            currentState.advanceConversation();\r\n                        }\r\n                    };\r\n                    this.transition = function (conversation) {\r\n                        currentState = conversation;\r\n                        var state = currentState.state;\r\n                        onStateChange(state.message);\r\n                        // If we are transitioning into SENDING or SPEAKING we want to immediately advance the conversation state\r\n                        // to start the service call or playback.\r\n                        if (state.message === state.messages.SENDING ||\r\n                            state.message === state.messages.SPEAKING) {\r\n                            currentState.advanceConversation();\r\n                        }\r\n                        // If we are transitioning in to sending and we are not detecting silence (this was a manual state change)\r\n                        // we need to do some cleanup: stop recording, and stop rendering.\r\n                        if (state.message === state.messages.SENDING &&\r\n                            !this.config.silenceDetection) {\r\n                            audioControl.stopRecording();\r\n                        }\r\n                    };\r\n                    this.advanceConversation = function () {\r\n                        audioControl.supportsAudio(function (supported) {\r\n                            if (supported) {\r\n                                currentState.advanceConversation();\r\n                            }\r\n                            else {\r\n                                onError('Audio is not supported.');\r\n                            }\r\n                        });\r\n                    };\r\n                    this.updateConfig = function (newValue) {\r\n                        this.config = applyDefaults(newValue);\r\n                        this.lexConfig = this.config.lexConfig;\r\n                    };\r\n                    this.reset = function () {\r\n                        audioControl.clear();\r\n                        currentState = new Initial(currentState.state);\r\n                    };\r\n                    currentState = new Initial(this);\r\n                    return {\r\n                        advanceConversation: this.advanceConversation,\r\n                        updateConfig: this.updateConfig,\r\n                        reset: this.reset,\r\n                    };\r\n                };\r\n                var Initial = function (state) {\r\n                    this.state = state;\r\n                    state.message = state.messages.PASSIVE;\r\n                    this.advanceConversation = function () {\r\n                        audioControl.startRecording(state.onSilence, state.onAudioData, state.config.silenceDetectionConfig);\r\n                        state.transition(new Listening(state));\r\n                    };\r\n                };\r\n                var Listening = function (state) {\r\n                    this.state = state;\r\n                    state.message = state.messages.LISTENING;\r\n                    this.advanceConversation = function () {\r\n                        audioControl.exportWAV(function (blob) {\r\n                            state.audioInput = blob;\r\n                            state.transition(new Sending(state));\r\n                        });\r\n                    };\r\n                };\r\n                var Sending = function (state) {\r\n                    this.state = state;\r\n                    state.message = state.messages.SENDING;\r\n                    this.advanceConversation = function () {\r\n                        state.lexConfig.inputStream = state.audioInput;\r\n                        lexruntime.postContent(state.lexConfig, function (err, data) {\r\n                            if (err) {\r\n                                state.onError(err);\r\n                                state.transition(new Initial(state));\r\n                            }\r\n                            else {\r\n                                state.audioOutput = data;\r\n                                state.transition(new Speaking(state));\r\n                                state.onSuccess(data);\r\n                            }\r\n                        });\r\n                    };\r\n                };\r\n                var Speaking = function (state) {\r\n                    this.state = state;\r\n                    state.message = state.messages.SPEAKING;\r\n                    this.advanceConversation = function () {\r\n                        if (state.audioOutput.contentType === 'audio/mpeg') {\r\n                            audioControl.play(state.audioOutput.audioStream, function () {\r\n                                if (state.audioOutput.dialogState === 'ReadyForFulfillment' ||\r\n                                    state.audioOutput.dialogState === 'Fulfilled' ||\r\n                                    state.audioOutput.dialogState === 'Failed' ||\r\n                                    !state.config.silenceDetection) {\r\n                                    state.transition(new Initial(state));\r\n                                }\r\n                                else {\r\n                                    audioControl.startRecording(state.onSilence, state.onAudioData, state.config.silenceDetectionConfig);\r\n                                    state.transition(new Listening(state));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            state.transition(new Initial(state));\r\n                        }\r\n                    };\r\n                };\r\n                var applyDefaults = function (config) {\r\n                    config = config || {};\r\n                    config.silenceDetection = config.hasOwnProperty('silenceDetection')\r\n                        ? config.silenceDetection\r\n                        : true;\r\n                    var lexConfig = config.lexConfig || {};\r\n                    lexConfig.botAlias = lexConfig.hasOwnProperty('botAlias')\r\n                        ? lexConfig.botAlias\r\n                        : DEFAULT_LATEST;\r\n                    lexConfig.botName = lexConfig.hasOwnProperty('botName')\r\n                        ? lexConfig.botName\r\n                        : '';\r\n                    lexConfig.contentType = lexConfig.hasOwnProperty('contentType')\r\n                        ? lexConfig.contentType\r\n                        : DEFAULT_CONTENT_TYPE;\r\n                    lexConfig.userId = lexConfig.hasOwnProperty('userId')\r\n                        ? lexConfig.userId\r\n                        : DEFAULT_USER_ID;\r\n                    lexConfig.accept = lexConfig.hasOwnProperty('accept')\r\n                        ? lexConfig.accept\r\n                        : DEFAULT_ACCEPT_HEADER_VALUE;\r\n                    config.lexConfig = lexConfig;\r\n                    return config;\r\n                };\r\n            })();\r\n        },\r\n        { './control.js': 1 },\r\n    ],\r\n    3: [\r\n        function (require, module, exports) {\r\n            (function (global) {\r\n                /**\r\n                 * @module LexAudio\r\n                 * @description The global namespace for Amazon Lex Audio\r\n                 */\r\n                global.LexAudio = global.LexAudio || {};\r\n                global.LexAudio.audioControl = require('./control.js').audioControl;\r\n                global.LexAudio.conversation = require('./conversation.js').conversation;\r\n                module.exports = global.LexAudio;\r\n            }.call(this, typeof global !== 'undefined'\r\n                ? global\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : {}));\r\n        },\r\n        { './control.js': 1, './conversation.js': 2 },\r\n    ],\r\n    4: [\r\n        function (require, module, exports) {\r\n            var bundleFn = arguments[3];\r\n            var sources = arguments[4];\r\n            var cache = arguments[5];\r\n            var stringify = JSON.stringify;\r\n            module.exports = function (fn, options) {\r\n                var wkey;\r\n                var cacheKeys = Object.keys(cache);\r\n                for (var i = 0, l = cacheKeys.length; i < l; i++) {\r\n                    var key = cacheKeys[i];\r\n                    var exp = cache[key].exports;\r\n                    // Using babel as a transpiler to use esmodule, the export will always\r\n                    // be an object with the default export as a property of it. To ensure\r\n                    // the existing api and babel esmodule exports are both supported we\r\n                    // check for both\r\n                    if (exp === fn || (exp && exp.default === fn)) {\r\n                        wkey = key;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!wkey) {\r\n                    wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\r\n                    var wcache = {};\r\n                    for (var i = 0, l = cacheKeys.length; i < l; i++) {\r\n                        var key = cacheKeys[i];\r\n                        wcache[key] = key;\r\n                    }\r\n                    sources[wkey] = [\r\n                        // @ts-ignore\r\n                        Function(['require', 'module', 'exports'], '(' + fn + ')(self)'),\r\n                        wcache,\r\n                    ];\r\n                }\r\n                var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\r\n                var scache = {};\r\n                scache[wkey] = wkey;\r\n                sources[skey] = [\r\n                    // @ts-ignore\r\n                    Function(\r\n                    // @ts-ignore\r\n                    ['require'], \r\n                    // try to call default if defined to also support babel esmodule\r\n                    // exports\r\n                    'var f = require(' +\r\n                        stringify(wkey) +\r\n                        ');' +\r\n                        '(f.default ? f.default : f)(self);'),\r\n                    scache,\r\n                ];\r\n                var workerSources = {};\r\n                resolveSources(skey);\r\n                function resolveSources(key) {\r\n                    workerSources[key] = true;\r\n                    for (var depPath in sources[key][1]) {\r\n                        var depKey = sources[key][1][depPath];\r\n                        if (!workerSources[depKey]) {\r\n                            resolveSources(depKey);\r\n                        }\r\n                    }\r\n                }\r\n                var src = '(' +\r\n                    bundleFn +\r\n                    ')({' +\r\n                    Object.keys(workerSources)\r\n                        .map(function (key) {\r\n                        return (stringify(key) +\r\n                            ':[' +\r\n                            sources[key][0] +\r\n                            ',' +\r\n                            stringify(sources[key][1]) +\r\n                            ']');\r\n                    })\r\n                        .join(',') +\r\n                    '},{},[' +\r\n                    stringify(skey) +\r\n                    '])';\r\n                // @ts-ignore\r\n                var URL = \r\n                // @ts-ignore\r\n                window.URL || window.webkitURL || window.mozURL || window.msURL;\r\n                var blob = new Blob([src], { type: 'text/javascript' });\r\n                if (options && options.bare) {\r\n                    return blob;\r\n                }\r\n                var workerUrl = URL.createObjectURL(blob);\r\n                var worker = new Worker(workerUrl);\r\n                // @ts-ignore\r\n                worker.objectURL = workerUrl;\r\n                return worker;\r\n            };\r\n        },\r\n        {},\r\n    ],\r\n    5: [\r\n        function (require, module, exports) {\r\n            (function () {\r\n                'use strict';\r\n                var work = require('webworkify');\r\n                var worker = work(require('./worker.js'));\r\n                var audio_context, audio_stream;\r\n                /**\r\n                 * The Recorder object. Sets up the onaudioprocess callback and communicates\r\n                 * with the web worker to perform audio actions.\r\n                 */\r\n                var recorder = function (source, silenceDetectionConfig) {\r\n                    silenceDetectionConfig = silenceDetectionConfig || {};\r\n                    silenceDetectionConfig.time = silenceDetectionConfig.hasOwnProperty('time')\r\n                        ? silenceDetectionConfig.time\r\n                        : 1500;\r\n                    silenceDetectionConfig.amplitude = silenceDetectionConfig.hasOwnProperty('amplitude')\r\n                        ? silenceDetectionConfig.amplitude\r\n                        : 0.2;\r\n                    var recording = false, currCallback, start, silenceCallback, visualizationCallback;\r\n                    // Create a ScriptProcessorNode with a bufferSize of 4096 and a single input and output channel\r\n                    var node = source.context.createScriptProcessor(4096, 1, 1);\r\n                    worker.onmessage = function (message) {\r\n                        var blob = message.data;\r\n                        currCallback(blob);\r\n                    };\r\n                    worker.postMessage({\r\n                        command: 'init',\r\n                        config: {\r\n                            sampleRate: source.context.sampleRate,\r\n                        },\r\n                    });\r\n                    /**\r\n                     * Sets the silence and viz callbacks, resets the silence start time, and sets recording to true.\r\n                     * @param {?onSilenceCallback} onSilence - Called when silence is detected.\r\n                     * @param {?visualizerCallback} visualizer - Can be used to visualize the captured buffer.\r\n                     */\r\n                    var record = function (onSilence, visualizer) {\r\n                        silenceCallback = onSilence;\r\n                        visualizationCallback = visualizer;\r\n                        start = Date.now();\r\n                        recording = true;\r\n                    };\r\n                    /**\r\n                     * Sets recording to false.\r\n                     */\r\n                    var stop = function () {\r\n                        recording = false;\r\n                    };\r\n                    /**\r\n                     * Posts \"clear\" message to the worker.\r\n                     */\r\n                    var clear = function () {\r\n                        stop();\r\n                        worker.postMessage({ command: 'clear' });\r\n                    };\r\n                    /**\r\n                     * Sets the export callback and posts an \"export\" message to the worker.\r\n                     * @param {onExportComplete} callback - Called when the export is complete.\r\n                     * @param {sampleRate} The sample rate to use in the export.\r\n                     */\r\n                    var exportWAV = function (callback, sampleRate) {\r\n                        currCallback = callback;\r\n                        worker.postMessage({\r\n                            command: 'export',\r\n                            sampleRate: sampleRate,\r\n                        });\r\n                    };\r\n                    /**\r\n                     * Checks the time domain data to see if the amplitude of the audio waveform is more than\r\n                     * the silence threshold. If it is, \"noise\" has been detected and it resets the start time.\r\n                     * If the elapsed time reaches the time threshold the silence callback is called. If there is a\r\n                     * visualizationCallback it invokes the visualization callback with the time domain data.\r\n                     */\r\n                    var analyse = function () {\r\n                        analyser.fftSize = 2048;\r\n                        var bufferLength = analyser.fftSize;\r\n                        var dataArray = new Uint8Array(bufferLength);\r\n                        var amplitude = silenceDetectionConfig.amplitude;\r\n                        var time = silenceDetectionConfig.time;\r\n                        analyser.getByteTimeDomainData(dataArray);\r\n                        if (typeof visualizationCallback === 'function') {\r\n                            visualizationCallback(dataArray, bufferLength);\r\n                        }\r\n                        for (var i = 0; i < bufferLength; i++) {\r\n                            // Normalize between -1 and 1.\r\n                            var curr_value_time = dataArray[i] / 128 - 1.0;\r\n                            if (curr_value_time > amplitude ||\r\n                                curr_value_time < -1 * amplitude) {\r\n                                start = Date.now();\r\n                            }\r\n                        }\r\n                        var newtime = Date.now();\r\n                        var elapsedTime = newtime - start;\r\n                        if (elapsedTime > time) {\r\n                            silenceCallback();\r\n                        }\r\n                    };\r\n                    /**\r\n                     * The onaudioprocess event handler of the ScriptProcessorNode interface. It is the EventHandler to be\r\n                     * called for the audioprocess event that is dispatched to ScriptProcessorNode node types.\r\n                     * @param {AudioProcessingEvent} audioProcessingEvent - The audio processing event.\r\n                     */\r\n                    node.onaudioprocess = function (audioProcessingEvent) {\r\n                        if (!recording) {\r\n                            return;\r\n                        }\r\n                        worker.postMessage({\r\n                            command: 'record',\r\n                            buffer: [audioProcessingEvent.inputBuffer.getChannelData(0)],\r\n                        });\r\n                        analyse();\r\n                    };\r\n                    var analyser = source.context.createAnalyser();\r\n                    analyser.minDecibels = -90;\r\n                    analyser.maxDecibels = -10;\r\n                    analyser.smoothingTimeConstant = 0.85;\r\n                    source.connect(analyser);\r\n                    analyser.connect(node);\r\n                    node.connect(source.context.destination);\r\n                    return {\r\n                        record: record,\r\n                        stop: stop,\r\n                        clear: clear,\r\n                        exportWAV: exportWAV,\r\n                    };\r\n                };\r\n                /**\r\n                 * Audio recorder object. Handles setting up the audio context,\r\n                 * accessing the mike, and creating the Recorder object.\r\n                 */\r\n                exports.audioRecorder = function () {\r\n                    /**\r\n                     * Creates an audio context and calls getUserMedia to request the mic (audio).\r\n                     */\r\n                    var requestDevice = function () {\r\n                        if (typeof audio_context === 'undefined') {\r\n                            // @ts-ignore\r\n                            window.AudioContext =\r\n                                // @ts-ignore\r\n                                window.AudioContext || window.webkitAudioContext;\r\n                            audio_context = new AudioContext();\r\n                        }\r\n                        return navigator.mediaDevices\r\n                            .getUserMedia({ audio: true })\r\n                            .then(function (stream) {\r\n                            audio_stream = stream;\r\n                        });\r\n                    };\r\n                    var createRecorder = function (silenceDetectionConfig) {\r\n                        return recorder(audio_context.createMediaStreamSource(audio_stream), silenceDetectionConfig);\r\n                    };\r\n                    var audioContext = function () {\r\n                        return audio_context;\r\n                    };\r\n                    return {\r\n                        requestDevice: requestDevice,\r\n                        createRecorder: createRecorder,\r\n                        audioContext: audioContext,\r\n                    };\r\n                };\r\n            })();\r\n        },\r\n        { './worker.js': 6, webworkify: 4 },\r\n    ],\r\n    6: [\r\n        function (require, module, exports) {\r\n            module.exports = function (self) {\r\n                'use strict';\r\n                var recLength = 0, recBuffer = [], recordSampleRate;\r\n                self.addEventListener('message', function (e) {\r\n                    switch (e.data.command) {\r\n                        case 'init':\r\n                            init(e.data.config);\r\n                            break;\r\n                        case 'record':\r\n                            record(e.data.buffer);\r\n                            break;\r\n                        case 'export':\r\n                            exportBuffer(e.data.sampleRate);\r\n                            break;\r\n                        case 'clear':\r\n                            clear();\r\n                            break;\r\n                    }\r\n                });\r\n                function init(config) {\r\n                    recordSampleRate = config.sampleRate;\r\n                }\r\n                function record(inputBuffer) {\r\n                    recBuffer.push(inputBuffer[0]);\r\n                    recLength += inputBuffer[0].length;\r\n                }\r\n                function exportBuffer(exportSampleRate) {\r\n                    var mergedBuffers = mergeBuffers(recBuffer, recLength);\r\n                    var downsampledBuffer = downsampleBuffer(mergedBuffers, exportSampleRate);\r\n                    var encodedWav = encodeWAV(downsampledBuffer);\r\n                    var audioBlob = new Blob([encodedWav], {\r\n                        type: 'application/octet-stream',\r\n                    });\r\n                    // @ts-ignore\r\n                    postMessage(audioBlob);\r\n                }\r\n                function clear() {\r\n                    recLength = 0;\r\n                    recBuffer = [];\r\n                }\r\n                function downsampleBuffer(buffer, exportSampleRate) {\r\n                    if (exportSampleRate === recordSampleRate) {\r\n                        return buffer;\r\n                    }\r\n                    var sampleRateRatio = recordSampleRate / exportSampleRate;\r\n                    var newLength = Math.round(buffer.length / sampleRateRatio);\r\n                    var result = new Float32Array(newLength);\r\n                    var offsetResult = 0;\r\n                    var offsetBuffer = 0;\r\n                    while (offsetResult < result.length) {\r\n                        var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\r\n                        var accum = 0, count = 0;\r\n                        for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\r\n                            accum += buffer[i];\r\n                            count++;\r\n                        }\r\n                        result[offsetResult] = accum / count;\r\n                        offsetResult++;\r\n                        offsetBuffer = nextOffsetBuffer;\r\n                    }\r\n                    return result;\r\n                }\r\n                function mergeBuffers(bufferArray, recLength) {\r\n                    var result = new Float32Array(recLength);\r\n                    var offset = 0;\r\n                    for (var i = 0; i < bufferArray.length; i++) {\r\n                        result.set(bufferArray[i], offset);\r\n                        offset += bufferArray[i].length;\r\n                    }\r\n                    return result;\r\n                }\r\n                function floatTo16BitPCM(output, offset, input) {\r\n                    for (var i = 0; i < input.length; i++, offset += 2) {\r\n                        var s = Math.max(-1, Math.min(1, input[i]));\r\n                        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n                    }\r\n                }\r\n                function writeString(view, offset, string) {\r\n                    for (var i = 0; i < string.length; i++) {\r\n                        view.setUint8(offset + i, string.charCodeAt(i));\r\n                    }\r\n                }\r\n                function encodeWAV(samples) {\r\n                    var buffer = new ArrayBuffer(44 + samples.length * 2);\r\n                    var view = new DataView(buffer);\r\n                    writeString(view, 0, 'RIFF');\r\n                    view.setUint32(4, 32 + samples.length * 2, true);\r\n                    writeString(view, 8, 'WAVE');\r\n                    writeString(view, 12, 'fmt ');\r\n                    view.setUint32(16, 16, true);\r\n                    view.setUint16(20, 1, true);\r\n                    view.setUint16(22, 1, true);\r\n                    view.setUint32(24, recordSampleRate, true);\r\n                    view.setUint32(28, recordSampleRate * 2, true);\r\n                    view.setUint16(32, 2, true);\r\n                    view.setUint16(34, 16, true);\r\n                    writeString(view, 36, 'data');\r\n                    view.setUint32(40, samples.length * 2, true);\r\n                    floatTo16BitPCM(view, 44, samples);\r\n                    return view;\r\n                }\r\n            };\r\n        },\r\n        {},\r\n    ],\r\n}, {}, [3]);\r\n//# sourceMappingURL=aws-lex-audio.js.map"]},"metadata":{},"sourceType":"script"}